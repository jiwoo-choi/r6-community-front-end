{"version":3,"sources":["../node_modules/mobx-utils/mobx-utils.module.js","../../../../src/internal/operators/switchMap.ts","../../../../src/internal/observable/forkJoin.ts"],"names":["fail$1","message","Error","invariant","cond","distinctDeepFields","x","deepFieldsIndistinct","deepFields","Object","prototype","getOwnPropertyNames","concat","getPrototypeOf","filter","item","index","indexOf","caseImpl","handlers","this","state","pending","value","rejected","fulfilled","fromPromise","origPromise","oldPromise","arguments","length","then","isPromiseBasedObservable","Promise","promise","action","reason","case","oldData","undefined","extendObservable","deep","reject","p","resolve","__decorate","decorators","target","key","desc","d","c","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","toStream","expression","fireImmediately","_a","computedValue","computed","subscribe","observer","unsubscribe","observe","newValue","next","Symbol","observable","StreamListener","initialValue","_this","runInAction","current","subscription","dispose","complete","error","ref","bound","__assign","assign","t","s","n","hasOwnProperty","call","apply","__decorate$1","RESERVED_NAMES","ViewModel","model","localValues","map","localComputedValues","isPropertyDirty","has","isObservableObject","name","forEach","$mobx","isComputedProp","derivation","_getAdministration","set","bind","descriptor","additionalDescriptor","enumerable","configurable","get","delete","size","toJS","submit","keys","source","destination","isObservableArray","replace","isObservableMap","clear","merge","isComputed","reset","resetProperty","__extends","extendStatics","b","setPrototypeOf","__proto__","Array","__","constructor","create","DeepMapEntry","_super","ObservableGroupMap","base","groupBy","_b","_c","Math","random","_d","keyToName","_keyToName","_groupBy","_ogmInfoKey","_base","_addItem","_disposeBaseObserver","change","type","transaction","_i","removed","_removeItem","added","oldValue","_key","_value","reaction","_getGroupArr","result","_removeFromGroupArr","itemIndex","arr","groupArrIndex","groupByValue","groupArr","newGroupByValue","_r","console","log","grouperItemInfo","newGroupArr","newGroupArrIndex","push","ObservableMap","args","closestIdx","isDisposed","closest","root","exists","assertNotDisposed","l","m","Map","maps","DeepMap","store","argsLength","entry","last","Set","queueMicrotaskPolyfill_1","taskOrderPromise_1","queueMicrotask","process","nextTick","cb","setTimeout","idle_1"],"mappings":"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","file":"static/js/7.94617e31.chunk.js","sourcesContent":["import { action, extendObservable, $mobx, observable, _allowStateChanges, createAtom, computed, runInAction, keys, isObservableArray, isObservableMap, isComputed, isObservableObject, isComputedProp, _getAdministration, when, getAtom, isAction, autorun, _isComputingDerivation, flow, onBecomeUnobserved, observe, entries, values, transaction, reaction, ObservableMap, _startAction, _endAction } from 'mobx';\n\nvar NOOP = function () { };\r\nvar IDENTITY = function (_) { return _; };\r\nfunction fail$1(message) {\r\n    throw new Error(\"[mobx-utils] \" + message);\r\n}\r\nfunction invariant(cond, message) {\r\n    if (message === void 0) { message = \"Illegal state\"; }\r\n    if (!cond)\r\n        fail$1(message);\r\n}\r\nvar deprecatedMessages = [];\r\nfunction deprecated(msg) {\r\n    if (deprecatedMessages.indexOf(msg) !== -1)\r\n        return;\r\n    deprecatedMessages.push(msg);\r\n    console.error(\"[mobx-utils] Deprecated: \" + msg);\r\n}\r\nfunction addHiddenProp(object, propName, value) {\r\n    Object.defineProperty(object, propName, {\r\n        enumerable: false,\r\n        writable: true,\r\n        configurable: true,\r\n        value: value,\r\n    });\r\n}\r\nvar deepFields = function (x) {\r\n    return (x &&\r\n        x !== Object.prototype &&\r\n        Object.getOwnPropertyNames(x).concat(deepFields(Object.getPrototypeOf(x)) || []));\r\n};\r\nvar distinctDeepFields = function (x) {\r\n    var deepFieldsIndistinct = deepFields(x);\r\n    var deepFieldsDistinct = deepFieldsIndistinct.filter(function (item, index) { return deepFieldsIndistinct.indexOf(item) === index; });\r\n    return deepFieldsDistinct;\r\n};\r\nvar getAllMethodsAndProperties = function (x) {\r\n    return distinctDeepFields(x).filter(function (name) { return name !== \"constructor\" && !~name.indexOf(\"__\"); });\r\n};\n\nvar PENDING = \"pending\";\r\nvar FULFILLED = \"fulfilled\";\r\nvar REJECTED = \"rejected\";\r\nfunction caseImpl(handlers) {\r\n    switch (this.state) {\r\n        case PENDING:\r\n            return handlers.pending && handlers.pending(this.value);\r\n        case REJECTED:\r\n            return handlers.rejected && handlers.rejected(this.value);\r\n        case FULFILLED:\r\n            return handlers.fulfilled ? handlers.fulfilled(this.value) : this.value;\r\n    }\r\n}\r\n/**\r\n * `fromPromise` takes a Promise, extends it with 2 observable properties that track\r\n * the status of the promise and returns it. The returned object has the following observable properties:\r\n *  - `value`: either the initial value, the value the Promise resolved to, or the value the Promise was rejected with. use `.state` if you need to be able to tell the difference.\r\n *  - `state`: one of `\"pending\"`, `\"fulfilled\"` or `\"rejected\"`\r\n *\r\n * And the following methods:\r\n * - `case({fulfilled, rejected, pending})`: maps over the result using the provided handlers, or returns `undefined` if a handler isn't available for the current promise state.\r\n * - `then((value: TValue) => TResult1 | PromiseLike<TResult1>, [(rejectReason: any) => any])`: chains additional handlers to the provided promise.\r\n *\r\n * The returned object implements `PromiseLike<TValue>`, so you can chain additional `Promise` handlers using `then`. You may also use it with `await` in `async` functions.\r\n *\r\n * Note that the status strings are available as constants:\r\n * `mobxUtils.PENDING`, `mobxUtils.REJECTED`, `mobxUtil.FULFILLED`\r\n *\r\n * fromPromise takes an optional second argument, a previously created `fromPromise` based observable.\r\n * This is useful to replace one promise based observable with another, without going back to an intermediate\r\n * \"pending\" promise state while fetching data. For example:\r\n *\r\n * @example\r\n * \\@observer\r\n * class SearchResults extends React.Component {\r\n *   \\@observable.ref searchResults\r\n *\r\n *   componentDidUpdate(nextProps) {\r\n *     if (nextProps.query !== this.props.query)\r\n *       this.searchResults = fromPromise(\r\n *         window.fetch(\"/search?q=\" + nextProps.query),\r\n *         // by passing, we won't render a pending state if we had a successful search query before\r\n *         // rather, we will keep showing the previous search results, until the new promise resolves (or rejects)\r\n *         this.searchResults\r\n *       )\r\n *   }\r\n *\r\n *   render() {\r\n *     return this.searchResults.case({\r\n *        pending: (staleValue) => {\r\n *          return staleValue || \"searching\" // <- value might set to previous results while the promise is still pending\r\n *        },\r\n *        fulfilled: (value) => {\r\n *          return value // the fresh results\r\n *        },\r\n *        rejected: (error) => {\r\n *          return \"Oops: \" + error\r\n *        }\r\n *     })\r\n *   }\r\n * }\r\n *\r\n * Observable promises can be created immediately in a certain state using\r\n * `fromPromise.reject(reason)` or `fromPromise.resolve(value?)`.\r\n * The main advantage of `fromPromise.resolve(value)` over `fromPromise(Promise.resolve(value))` is that the first _synchronously_ starts in the desired state.\r\n *\r\n * It is possible to directly create a promise using a resolve, reject function:\r\n * `fromPromise((resolve, reject) => setTimeout(() => resolve(true), 1000))`\r\n *\r\n * @example\r\n * const fetchResult = fromPromise(fetch(\"http://someurl\"))\r\n *\r\n * // combine with when..\r\n * when(\r\n *   () => fetchResult.state !== \"pending\",\r\n *   () => {\r\n *     console.log(\"Got \", fetchResult.value)\r\n *   }\r\n * )\r\n *\r\n * // or a mobx-react component..\r\n * const myComponent = observer(({ fetchResult }) => {\r\n *   switch(fetchResult.state) {\r\n *      case \"pending\": return <div>Loading...</div>\r\n *      case \"rejected\": return <div>Ooops... {fetchResult.value}</div>\r\n *      case \"fulfilled\": return <div>Gotcha: {fetchResult.value}</div>\r\n *   }\r\n * })\r\n *\r\n * // or using the case method instead of switch:\r\n *\r\n * const myComponent = observer(({ fetchResult }) =>\r\n *   fetchResult.case({\r\n *     pending:   () => <div>Loading...</div>,\r\n *     rejected:  error => <div>Ooops.. {error}</div>,\r\n *     fulfilled: value => <div>Gotcha: {value}</div>,\r\n *   }))\r\n *\r\n * // chain additional handler(s) to the resolve/reject:\r\n *\r\n * fetchResult.then(\r\n *   (result) =>  doSomeTransformation(result),\r\n *   (rejectReason) => console.error('fetchResult was rejected, reason: ' + rejectReason)\r\n * ).then(\r\n *   (transformedResult) => console.log('transformed fetchResult: ' + transformedResult)\r\n * )\r\n *\r\n * @param {IThenable<T>} promise The promise which will be observed\r\n * @param {IThenable<T>} oldPromise? The previously observed promise\r\n * @returns {IPromiseBasedObservable<T>}\r\n */\r\nfunction fromPromise(origPromise, oldPromise) {\r\n    invariant(arguments.length <= 2, \"fromPromise expects up to two arguments\");\r\n    invariant(typeof origPromise === \"function\" ||\r\n        (typeof origPromise === \"object\" &&\r\n            origPromise &&\r\n            typeof origPromise.then === \"function\"), \"Please pass a promise or function to fromPromise\");\r\n    if (origPromise.isPromiseBasedObservable === true)\r\n        return origPromise;\r\n    if (typeof origPromise === \"function\") {\r\n        // If it is a (reject, resolve function, wrap it)\r\n        origPromise = new Promise(origPromise);\r\n    }\r\n    var promise = origPromise;\r\n    origPromise.then(action(\"observableFromPromise-resolve\", function (value) {\r\n        promise.value = value;\r\n        promise.state = FULFILLED;\r\n    }), action(\"observableFromPromise-reject\", function (reason) {\r\n        promise.value = reason;\r\n        promise.state = REJECTED;\r\n    }));\r\n    promise.isPromiseBasedObservable = true;\r\n    promise.case = caseImpl;\r\n    var oldData = oldPromise && oldPromise.state === FULFILLED\r\n        ? oldPromise.value\r\n        : undefined;\r\n    extendObservable(promise, {\r\n        value: oldData,\r\n        state: PENDING,\r\n    }, {}, { deep: false });\r\n    return promise;\r\n}\r\n(function (fromPromise) {\r\n    fromPromise.reject = action(\"fromPromise.reject\", function (reason) {\r\n        var p = fromPromise(Promise.reject(reason));\r\n        p.state = REJECTED;\r\n        p.value = reason;\r\n        return p;\r\n    });\r\n    function resolveBase(value) {\r\n        if (value === void 0) { value = undefined; }\r\n        var p = fromPromise(Promise.resolve(value));\r\n        p.state = FULFILLED;\r\n        p.value = value;\r\n        return p;\r\n    }\r\n    fromPromise.resolve = action(\"fromPromise.resolve\", resolveBase);\r\n})(fromPromise || (fromPromise = {}));\r\n/**\r\n * Returns true if the provided value is a promise-based observable.\r\n * @param value any\r\n * @returns {boolean}\r\n */\r\nfunction isPromiseBasedObservable(value) {\r\n    return value && value.isPromiseBasedObservable === true;\r\n}\n\nvar __spreadArrays = (undefined && undefined.__spreadArrays) || function () {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n/**\r\n * Moves an item from one position to another, checking that the indexes given are within bounds.\r\n *\r\n * @example\r\n * const source = observable([1, 2, 3])\r\n * moveItem(source, 0, 1)\r\n * console.log(source.map(x => x)) // [2, 1, 3]\r\n *\r\n * @export\r\n * @param {ObservableArray<T>} target\r\n * @param {number} fromIndex\r\n * @param {number} toIndex\r\n * @returns {ObservableArray<T>}\r\n */\r\nfunction moveItem(target, fromIndex, toIndex) {\r\n    checkIndex(target, fromIndex);\r\n    checkIndex(target, toIndex);\r\n    if (fromIndex === toIndex) {\r\n        return;\r\n    }\r\n    var oldItems = target[$mobx].values;\r\n    var newItems;\r\n    if (fromIndex < toIndex) {\r\n        newItems = __spreadArrays(oldItems.slice(0, fromIndex), oldItems.slice(fromIndex + 1, toIndex + 1), [\r\n            oldItems[fromIndex]\r\n        ], oldItems.slice(toIndex + 1));\r\n    }\r\n    else {\r\n        // toIndex < fromIndex\r\n        newItems = __spreadArrays(oldItems.slice(0, toIndex), [\r\n            oldItems[fromIndex]\r\n        ], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\r\n    }\r\n    target.replace(newItems);\r\n    return target;\r\n}\r\n/**\r\n * Checks whether the specified index is within bounds. Throws if not.\r\n *\r\n * @private\r\n * @param {ObservableArray<any>} target\r\n * @param {number }index\r\n */\r\nfunction checkIndex(target, index) {\r\n    if (index < 0) {\r\n        throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\r\n    }\r\n    var length = target[$mobx].values.length;\r\n    if (index >= length) {\r\n        throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\r\n    }\r\n}\n\n/**\r\n * `lazyObservable` creates an observable around a `fetch` method that will not be invoked\r\n * until the observable is needed the first time.\r\n * The fetch method receives a `sink` callback which can be used to replace the\r\n * current value of the lazyObservable. It is allowed to call `sink` multiple times\r\n * to keep the lazyObservable up to date with some external resource.\r\n *\r\n * Note that it is the `current()` call itself which is being tracked by MobX,\r\n * so make sure that you don't dereference to early.\r\n *\r\n * @example\r\n * const userProfile = lazyObservable(\r\n *   sink => fetch(\"/myprofile\").then(profile => sink(profile))\r\n * )\r\n *\r\n * // use the userProfile in a React component:\r\n * const Profile = observer(({ userProfile }) =>\r\n *   userProfile.current() === undefined\r\n *   ? <div>Loading user profile...</div>\r\n *   : <div>{userProfile.current().displayName}</div>\r\n * )\r\n *\r\n * // triggers refresh the userProfile\r\n * userProfile.refresh()\r\n *\r\n * @param {(sink: (newValue: T) => void) => void} fetch method that will be called the first time the value of this observable is accessed. The provided sink can be used to produce a new value, synchronously or asynchronously\r\n * @param {T} [initialValue=undefined] optional initialValue that will be returned from `current` as long as the `sink` has not been called at least once\r\n * @returns {{\r\n *     current(): T,\r\n *     refresh(): T,\r\n *     reset(): T\r\n *     pending: boolean\r\n * }}\r\n */\r\nfunction lazyObservable(fetch, initialValue) {\r\n    if (initialValue === void 0) { initialValue = undefined; }\r\n    var started = false;\r\n    var value = observable.box(initialValue, { deep: false });\r\n    var pending = observable.box(false);\r\n    var currentFnc = function () {\r\n        if (!started) {\r\n            started = true;\r\n            _allowStateChanges(true, function () {\r\n                pending.set(true);\r\n            });\r\n            fetch(function (newValue) {\r\n                _allowStateChanges(true, function () {\r\n                    value.set(newValue);\r\n                    pending.set(false);\r\n                });\r\n            });\r\n        }\r\n        return value.get();\r\n    };\r\n    var resetFnc = action(\"lazyObservable-reset\", function () {\r\n        started = false;\r\n        value.set(initialValue);\r\n        return value.get();\r\n    });\r\n    return {\r\n        current: currentFnc,\r\n        refresh: function () {\r\n            if (started) {\r\n                started = false;\r\n                return currentFnc();\r\n            }\r\n            else {\r\n                return value.get();\r\n            }\r\n        },\r\n        reset: function () {\r\n            return resetFnc();\r\n        },\r\n        get pending() {\r\n            return pending.get();\r\n        },\r\n    };\r\n}\n\n/**\r\n * `fromResource` creates an observable whose current state can be inspected using `.current()`,\r\n * and which can be kept in sync with some external datasource that can be subscribed to.\r\n *\r\n * The created observable will only subscribe to the datasource if it is in use somewhere,\r\n * (un)subscribing when needed. To enable `fromResource` to do that two callbacks need to be provided,\r\n * one to subscribe, and one to unsubscribe. The subscribe callback itself will receive a `sink` callback, which can be used\r\n * to update the current state of the observable, allowing observes to react.\r\n *\r\n * Whatever is passed to `sink` will be returned by `current()`. The values passed to the sink will not be converted to\r\n * observables automatically, but feel free to do so.\r\n * It is the `current()` call itself which is being tracked,\r\n * so make sure that you don't dereference to early.\r\n *\r\n * For inspiration, an example integration with the apollo-client on [github](https://github.com/apollostack/apollo-client/issues/503#issuecomment-241101379),\r\n * or the [implementation](https://github.com/mobxjs/mobx-utils/blob/1d17cf7f7f5200937f68cc0b5e7ec7f3f71dccba/src/now.ts#L43-L57) of `mobxUtils.now`\r\n *\r\n * The following example code creates an observable that connects to a `dbUserRecord`,\r\n * which comes from an imaginary database and notifies when it has changed.\r\n *\r\n * @example\r\n * function createObservableUser(dbUserRecord) {\r\n *   let currentSubscription;\r\n *   return fromResource(\r\n *     (sink) => {\r\n *       // sink the current state\r\n *       sink(dbUserRecord.fields)\r\n *       // subscribe to the record, invoke the sink callback whenever new data arrives\r\n *       currentSubscription = dbUserRecord.onUpdated(() => {\r\n *         sink(dbUserRecord.fields)\r\n *       })\r\n *     },\r\n *     () => {\r\n *       // the user observable is not in use at the moment, unsubscribe (for now)\r\n *       dbUserRecord.unsubscribe(currentSubscription)\r\n *     }\r\n *   )\r\n * }\r\n *\r\n * // usage:\r\n * const myUserObservable = createObservableUser(myDatabaseConnector.query(\"name = 'Michel'\"))\r\n *\r\n * // use the observable in autorun\r\n * autorun(() => {\r\n *   // printed everytime the database updates its records\r\n *   console.log(myUserObservable.current().displayName)\r\n * })\r\n *\r\n * // ... or a component\r\n * const userComponent = observer(({ user }) =>\r\n *   <div>{user.current().displayName}</div>\r\n * )\r\n *\r\n * @export\r\n * @template T\r\n * @param {(sink: (newValue: T) => void) => void} subscriber\r\n * @param {IDisposer} [unsubscriber=NOOP]\r\n * @param {T} [initialValue=undefined] the data that will be returned by `get()` until the `sink` has emitted its first data\r\n * @returns {{\r\n *     current(): T;\r\n *     dispose(): void;\r\n *     isAlive(): boolean;\r\n * }}\r\n */\r\nfunction fromResource(subscriber, unsubscriber, initialValue) {\r\n    if (unsubscriber === void 0) { unsubscriber = NOOP; }\r\n    if (initialValue === void 0) { initialValue = undefined; }\r\n    var isActive = false;\r\n    var isDisposed = false;\r\n    var value = initialValue;\r\n    var suspender = function () {\r\n        if (isActive) {\r\n            isActive = false;\r\n            unsubscriber();\r\n        }\r\n    };\r\n    var atom = createAtom(\"ResourceBasedObservable\", function () {\r\n        invariant(!isActive && !isDisposed);\r\n        isActive = true;\r\n        subscriber(function (newValue) {\r\n            _allowStateChanges(true, function () {\r\n                value = newValue;\r\n                atom.reportChanged();\r\n            });\r\n        });\r\n    }, suspender);\r\n    return {\r\n        current: function () {\r\n            invariant(!isDisposed, \"subscribingObservable has already been disposed\");\r\n            var isBeingTracked = atom.reportObserved();\r\n            if (!isBeingTracked && !isActive)\r\n                console.warn(\"Called `get` of a subscribingObservable outside a reaction. Current value will be returned but no new subscription has started\");\r\n            return value;\r\n        },\r\n        dispose: function () {\r\n            isDisposed = true;\r\n            suspender();\r\n        },\r\n        isAlive: function () { return isActive; },\r\n    };\r\n}\n\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nfunction observableSymbol() {\r\n    return (typeof Symbol === \"function\" && Symbol.observable) || \"@@observable\";\r\n}\r\n/**\r\n * Converts an expression to an observable stream (a.k.a. TC 39 Observable / RxJS observable).\r\n * The provided expression is tracked by mobx as long as there are subscribers, automatically\r\n * emitting when new values become available. The expressions respect (trans)actions.\r\n *\r\n * @example\r\n *\r\n * const user = observable({\r\n *   firstName: \"C.S\",\r\n *   lastName: \"Lewis\"\r\n * })\r\n *\r\n * Rx.Observable\r\n *   .from(mobxUtils.toStream(() => user.firstname + user.lastName))\r\n *   .scan(nameChanges => nameChanges + 1, 0)\r\n *   .subscribe(nameChanges => console.log(\"Changed name \", nameChanges, \"times\"))\r\n *\r\n * @export\r\n * @template T\r\n * @param {() => T} expression\r\n * @param {boolean} fireImmediately (by default false)\r\n * @returns {IObservableStream<T>}\r\n */\r\nfunction toStream(expression, fireImmediately) {\r\n    var _a;\r\n    if (fireImmediately === void 0) { fireImmediately = false; }\r\n    var computedValue = computed(expression);\r\n    return _a = {\r\n            subscribe: function (observer) {\r\n                if (\"function\" === typeof observer) {\r\n                    return {\r\n                        unsubscribe: computedValue.observe(function (_a) {\r\n                            var newValue = _a.newValue;\r\n                            return observer(newValue);\r\n                        }, fireImmediately),\r\n                    };\r\n                }\r\n                if (observer && \"object\" === typeof observer && observer.next) {\r\n                    return {\r\n                        unsubscribe: computedValue.observe(function (_a) {\r\n                            var newValue = _a.newValue;\r\n                            return observer.next(newValue);\r\n                        }, fireImmediately),\r\n                    };\r\n                }\r\n                return {\r\n                    unsubscribe: function () { },\r\n                };\r\n            }\r\n        },\r\n        _a[observableSymbol()] = function () {\r\n            return this;\r\n        },\r\n        _a;\r\n}\r\nvar StreamListener = /** @class */ (function () {\r\n    function StreamListener(observable, initialValue) {\r\n        var _this = this;\r\n        runInAction(function () {\r\n            _this.current = initialValue;\r\n            _this.subscription = observable.subscribe(_this);\r\n        });\r\n    }\r\n    StreamListener.prototype.dispose = function () {\r\n        if (this.subscription) {\r\n            this.subscription.unsubscribe();\r\n        }\r\n    };\r\n    StreamListener.prototype.next = function (value) {\r\n        this.current = value;\r\n    };\r\n    StreamListener.prototype.complete = function () {\r\n        this.dispose();\r\n    };\r\n    StreamListener.prototype.error = function (value) {\r\n        this.current = value;\r\n        this.dispose();\r\n    };\r\n    __decorate([\r\n        observable.ref\r\n    ], StreamListener.prototype, \"current\", void 0);\r\n    __decorate([\r\n        action.bound\r\n    ], StreamListener.prototype, \"next\", null);\r\n    __decorate([\r\n        action.bound\r\n    ], StreamListener.prototype, \"complete\", null);\r\n    __decorate([\r\n        action.bound\r\n    ], StreamListener.prototype, \"error\", null);\r\n    return StreamListener;\r\n}());\r\nfunction fromStream(observable, initialValue) {\r\n    if (initialValue === void 0) { initialValue = undefined; }\r\n    return new StreamListener(observable, initialValue);\r\n}\n\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\nvar RESERVED_NAMES = [\"model\", \"reset\", \"submit\", \"isDirty\", \"isPropertyDirty\", \"resetProperty\"];\r\nvar ViewModel = /** @class */ (function () {\r\n    function ViewModel(model) {\r\n        var _this = this;\r\n        this.model = model;\r\n        this.localValues = observable.map({});\r\n        this.localComputedValues = observable.map({});\r\n        this.isPropertyDirty = function (key) {\r\n            return _this.localValues.has(key);\r\n        };\r\n        invariant(isObservableObject(model), \"createViewModel expects an observable object\");\r\n        // use this helper as Object.getOwnPropertyNames doesn't return getters\r\n        getAllMethodsAndProperties(model).forEach(function (key) {\r\n            if (key === $mobx || key === \"__mobxDidRunLazyInitializers\") {\r\n                return;\r\n            }\r\n            invariant(RESERVED_NAMES.indexOf(key) === -1, \"The propertyname \" + key + \" is reserved and cannot be used with viewModels\");\r\n            if (isComputedProp(model, key)) {\r\n                var derivation = _getAdministration(model, key).derivation; // Fixme: there is no clear api to get the derivation\r\n                _this.localComputedValues.set(key, computed(derivation.bind(_this)));\r\n            }\r\n            var descriptor = Object.getOwnPropertyDescriptor(model, key);\r\n            var additionalDescriptor = descriptor ? { enumerable: descriptor.enumerable } : {};\r\n            Object.defineProperty(_this, key, __assign(__assign({}, additionalDescriptor), { configurable: true, get: function () {\r\n                    if (isComputedProp(model, key))\r\n                        return _this.localComputedValues.get(key).get();\r\n                    if (_this.isPropertyDirty(key))\r\n                        return _this.localValues.get(key);\r\n                    else\r\n                        return _this.model[key];\r\n                }, set: action(function (value) {\r\n                    if (value !== _this.model[key]) {\r\n                        _this.localValues.set(key, value);\r\n                    }\r\n                    else {\r\n                        _this.localValues.delete(key);\r\n                    }\r\n                }) }));\r\n        });\r\n    }\r\n    Object.defineProperty(ViewModel.prototype, \"isDirty\", {\r\n        get: function () {\r\n            return this.localValues.size > 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(ViewModel.prototype, \"changedValues\", {\r\n        get: function () {\r\n            return this.localValues.toJS();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    ViewModel.prototype.submit = function () {\r\n        var _this = this;\r\n        keys(this.localValues).forEach(function (key) {\r\n            var source = _this.localValues.get(key);\r\n            var destination = _this.model[key];\r\n            if (isObservableArray(destination)) {\r\n                destination.replace(source);\r\n            }\r\n            else if (isObservableMap(destination)) {\r\n                destination.clear();\r\n                destination.merge(source);\r\n            }\r\n            else if (!isComputed(source)) {\r\n                _this.model[key] = source;\r\n            }\r\n        });\r\n        this.localValues.clear();\r\n    };\r\n    ViewModel.prototype.reset = function () {\r\n        this.localValues.clear();\r\n    };\r\n    ViewModel.prototype.resetProperty = function (key) {\r\n        this.localValues.delete(key);\r\n    };\r\n    __decorate$1([\r\n        computed\r\n    ], ViewModel.prototype, \"isDirty\", null);\r\n    __decorate$1([\r\n        computed\r\n    ], ViewModel.prototype, \"changedValues\", null);\r\n    __decorate$1([\r\n        action.bound\r\n    ], ViewModel.prototype, \"submit\", null);\r\n    __decorate$1([\r\n        action.bound\r\n    ], ViewModel.prototype, \"reset\", null);\r\n    __decorate$1([\r\n        action.bound\r\n    ], ViewModel.prototype, \"resetProperty\", null);\r\n    return ViewModel;\r\n}());\r\n/**\r\n * `createViewModel` takes an object with observable properties (model)\r\n * and wraps a viewmodel around it. The viewmodel proxies all enumerable properties of the original model with the following behavior:\r\n *  - as long as no new value has been assigned to the viewmodel property, the original property will be returned.\r\n *  - any future change in the model will be visible in the viewmodel as well unless the viewmodel property was dirty at the time of the attempted change.\r\n *  - once a new value has been assigned to a property of the viewmodel, that value will be returned during a read of that property in the future. However, the original model remain untouched until `submit()` is called.\r\n *\r\n * The viewmodel exposes the following additional methods, besides all the enumerable properties of the model:\r\n * - `submit()`: copies all the values of the viewmodel to the model and resets the state\r\n * - `reset()`: resets the state of the viewmodel, abandoning all local modifications\r\n * - `resetProperty(propName)`: resets the specified property of the viewmodel\r\n * - `isDirty`: observable property indicating if the viewModel contains any modifications\r\n * - `isPropertyDirty(propName)`: returns true if the specified property is dirty\r\n * - `changedValues`: returns a key / value map with the properties that have been changed in the model so far\r\n * - `model`: The original model object for which this viewModel was created\r\n *\r\n * You may use observable arrays, maps and objects with `createViewModel` but keep in mind to assign fresh instances of those to the viewmodel's properties, otherwise you would end up modifying the properties of the original model.\r\n * Note that if you read a non-dirty property, viewmodel only proxies the read to the model. You therefore need to assign a fresh instance not only the first time you make the assignment but also after calling `reset()` or `submit()`.\r\n *\r\n * @example\r\n * class Todo {\r\n *   \\@observable title = \"Test\"\r\n * }\r\n *\r\n * const model = new Todo()\r\n * const viewModel = createViewModel(model);\r\n *\r\n * autorun(() => console.log(viewModel.model.title, \",\", viewModel.title))\r\n * // prints \"Test, Test\"\r\n * model.title = \"Get coffee\"\r\n * // prints \"Get coffee, Get coffee\", viewModel just proxies to model\r\n * viewModel.title = \"Get tea\"\r\n * // prints \"Get coffee, Get tea\", viewModel's title is now dirty, and the local value will be printed\r\n * viewModel.submit()\r\n * // prints \"Get tea, Get tea\", changes submitted from the viewModel to the model, viewModel is proxying again\r\n * viewModel.title = \"Get cookie\"\r\n * // prints \"Get tea, Get cookie\" // viewModel has diverged again\r\n * viewModel.reset()\r\n * // prints \"Get tea, Get tea\", changes of the viewModel have been abandoned\r\n *\r\n * @param {T} model\r\n * @returns {(T & IViewModel<T>)}\r\n * ```\r\n */\r\nfunction createViewModel(model) {\r\n    return new ViewModel(model);\r\n}\n\n/**\r\n * Like normal `when`, except that this `when` will automatically dispose if the condition isn't met within a certain amount of time.\r\n *\r\n * @example\r\n * test(\"expect store to load\", t => {\r\n *   const store = {\r\n *     items: [],\r\n *     loaded: false\r\n *   }\r\n *   fetchDataForStore((data) => {\r\n *     store.items = data;\r\n *     store.loaded = true;\r\n *   })\r\n *   whenWithTimeout(\r\n *     () => store.loaded\r\n *     () => t.end()\r\n *     2000,\r\n *     () => t.fail(\"store didn't load with 2 secs\")\r\n *   )\r\n * })\r\n *\r\n *\r\n * @export\r\n * @param {() => boolean} expr see when, the expression to await\r\n * @param {() => void} action see when, the action to execut when expr returns truthy\r\n * @param {number} [timeout=10000] maximum amount when spends waiting before giving up\r\n * @param {any} [onTimeout=() => {}] the ontimeout handler will be called if the condition wasn't met within the given time\r\n * @returns {IDisposer} disposer function that can be used to cancel the when prematurely. Neither action or onTimeout will be fired if disposed\r\n */\r\nfunction whenWithTimeout(expr, action, timeout, onTimeout) {\r\n    if (timeout === void 0) { timeout = 10000; }\r\n    if (onTimeout === void 0) { onTimeout = function () { }; }\r\n    deprecated(\"whenWithTimeout is deprecated, use mobx.when with timeout option instead\");\r\n    return when(expr, action, {\r\n        timeout: timeout,\r\n        onError: onTimeout,\r\n    });\r\n}\n\n/**\r\n * MobX normally suspends any computed value that is not in use by any reaction,\r\n * and lazily re-evaluates the expression if needed outside a reaction while not in use.\r\n * `keepAlive` marks a computed value as always in use, meaning that it will always fresh, but never disposed automatically.\r\n *\r\n * @example\r\n * const obj = observable({\r\n *   number: 3,\r\n *   doubler: function() { return this.number * 2 }\r\n * })\r\n * const stop = keepAlive(obj, \"doubler\")\r\n *\r\n * @param {Object} target an object that has a computed property, created by `@computed` or `extendObservable`\r\n * @param {string} property the name of the property to keep alive\r\n * @returns {IDisposer} stops this keep alive so that the computed value goes back to normal behavior\r\n */\r\n/**\r\n * @example\r\n * const number = observable(3)\r\n * const doubler = computed(() => number.get() * 2)\r\n * const stop = keepAlive(doubler)\r\n * // doubler will now stay in sync reactively even when there are no further observers\r\n * stop()\r\n * // normal behavior, doubler results will be recomputed if not observed but needed, but lazily\r\n *\r\n * @param {IComputedValue<any>} computedValue created using the `computed` function\r\n * @returns {IDisposer} stops this keep alive so that the computed value goes back to normal behavior\r\n */\r\nfunction keepAlive(_1, _2) {\r\n    var computed = getAtom(_1, _2);\r\n    if (!computed)\r\n        throw new Error(\"No computed provided, please provide an object created with `computed(() => expr)` or an object + property name\");\r\n    return computed.observe(function () { });\r\n}\n\n/**\r\n * `queueProcessor` takes an observable array, observes it and calls `processor`\r\n * once for each item added to the observable array, optionally debouncing the action\r\n *\r\n * @example\r\n * const pendingNotifications = observable([])\r\n * const stop = queueProcessor(pendingNotifications, msg => {\r\n *   // show Desktop notification\r\n *   new Notification(msg);\r\n * })\r\n *\r\n * // usage:\r\n * pendingNotifications.push(\"test!\")\r\n *\r\n * @param {T[]} observableArray observable array instance to track\r\n * @param {(item: T) => void} processor action to call per item\r\n * @param {number} [debounce=0] optional debounce time in ms. With debounce 0 the processor will run synchronously\r\n * @returns {IDisposer} stops the processor\r\n */\r\nfunction queueProcessor(observableArray, processor, debounce) {\r\n    if (debounce === void 0) { debounce = 0; }\r\n    if (!isObservableArray(observableArray))\r\n        throw new Error(\"Expected observable array as first argument\");\r\n    if (!isAction(processor))\r\n        processor = action(\"queueProcessor\", processor);\r\n    var runner = function () {\r\n        // construct a final set\r\n        var items = observableArray.slice(0);\r\n        // clear the queue for next iteration\r\n        runInAction(function () { return observableArray.splice(0); });\r\n        // fire processor\r\n        items.forEach(processor);\r\n    };\r\n    if (debounce > 0)\r\n        return autorun(runner, { delay: debounce });\r\n    else\r\n        return autorun(runner);\r\n}\n\n/**\r\n * `chunkProcessor` takes an observable array, observes it and calls `processor`\r\n * once for a chunk of items added to the observable array, optionally deboucing the action.\r\n * The maximum chunk size can be limited by number.\r\n * This allows both, splitting larger into smaller chunks or (when debounced) combining smaller\r\n * chunks and/or single items into reasonable chunks of work.\r\n *\r\n * @example\r\n * const trackedActions = observable([])\r\n * const stop = chunkProcessor(trackedActions, chunkOfMax10Items => {\r\n *   sendTrackedActionsToServer(chunkOfMax10Items);\r\n * }, 100, 10)\r\n *\r\n * // usage:\r\n * trackedActions.push(\"scrolled\")\r\n * trackedActions.push(\"hoveredButton\")\r\n * // when both pushes happen within 100ms, there will be only one call to server\r\n *\r\n * @param {T[]} observableArray observable array instance to track\r\n * @param {(item: T[]) => void} processor action to call per item\r\n * @param {number} [debounce=0] optional debounce time in ms. With debounce 0 the processor will run synchronously\r\n * @param {number} [maxChunkSize=0] optionally do not call on full array but smaller chunks. With 0 it will process the full array.\r\n * @returns {IDisposer} stops the processor\r\n */\r\nfunction chunkProcessor(observableArray, processor, debounce, maxChunkSize) {\r\n    if (debounce === void 0) { debounce = 0; }\r\n    if (maxChunkSize === void 0) { maxChunkSize = 0; }\r\n    if (!isObservableArray(observableArray))\r\n        throw new Error(\"Expected observable array as first argument\");\r\n    if (!isAction(processor))\r\n        processor = action(\"chunkProcessor\", processor);\r\n    var runner = function () {\r\n        var _loop_1 = function () {\r\n            var chunkSize = maxChunkSize === 0\r\n                ? observableArray.length\r\n                : Math.min(observableArray.length, maxChunkSize);\r\n            // construct a final set\r\n            var items = observableArray.slice(0, chunkSize);\r\n            // clear the slice for next iteration\r\n            runInAction(function () { return observableArray.splice(0, chunkSize); });\r\n            // fire processor\r\n            processor(items);\r\n        };\r\n        while (observableArray.length > 0) {\r\n            _loop_1();\r\n        }\r\n    };\r\n    if (debounce > 0)\r\n        return autorun(runner, { delay: debounce });\r\n    else\r\n        return autorun(runner);\r\n}\n\nvar tickers = {};\r\n/**\r\n * Returns the current date time as epoch number.\r\n * The date time is read from an observable which is updated automatically after the given interval.\r\n * So basically it treats time as an observable.\r\n *\r\n * The function takes an interval as parameter, which indicates how often `now()` will return a new value.\r\n * If no interval is given, it will update each second. If \"frame\" is specified, it will update each time a\r\n * `requestAnimationFrame` is available.\r\n *\r\n * Multiple clocks with the same interval will automatically be synchronized.\r\n *\r\n * Countdown example: https://jsfiddle.net/mweststrate/na0qdmkw/\r\n *\r\n * @example\r\n *\r\n * const start = Date.now()\r\n *\r\n * autorun(() => {\r\n *   console.log(\"Seconds elapsed: \", (mobxUtils.now() - start) / 1000)\r\n * })\r\n *\r\n *\r\n * @export\r\n * @param {(number | \"frame\")} [interval=1000] interval in milliseconds about how often the interval should update\r\n * @returns\r\n */\r\nfunction now(interval) {\r\n    if (interval === void 0) { interval = 1000; }\r\n    if (!_isComputingDerivation()) {\r\n        // See #40\r\n        return Date.now();\r\n    }\r\n    if (!tickers[interval]) {\r\n        if (typeof interval === \"number\")\r\n            tickers[interval] = createIntervalTicker(interval);\r\n        else\r\n            tickers[interval] = createAnimationFrameTicker();\r\n    }\r\n    return tickers[interval].current();\r\n}\r\nfunction createIntervalTicker(interval) {\r\n    var subscriptionHandle;\r\n    return fromResource(function (sink) {\r\n        subscriptionHandle = setInterval(function () { return sink(Date.now()); }, interval);\r\n    }, function () {\r\n        clearInterval(subscriptionHandle);\r\n    }, Date.now());\r\n}\r\nfunction createAnimationFrameTicker() {\r\n    var frameBasedTicker = fromResource(function (sink) {\r\n        function scheduleTick() {\r\n            window.requestAnimationFrame(function () {\r\n                sink(Date.now());\r\n                if (frameBasedTicker.isAlive())\r\n                    scheduleTick();\r\n            });\r\n        }\r\n        scheduleTick();\r\n    }, function () { }, Date.now());\r\n    return frameBasedTicker;\r\n}\n\nvar __assign$1 = (undefined && undefined.__assign) || function () {\r\n    __assign$1 = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign$1.apply(this, arguments);\r\n};\r\n/**\r\n * _deprecated_ this functionality can now be found as `flow` in the mobx package. However, `flow` is not applicable as decorator, where `asyncAction` still is.\r\n *\r\n *\r\n *\r\n * `asyncAction` takes a generator function and automatically wraps all parts of the process in actions. See the examples below.\r\n * `asyncAction` can be used both as decorator or to wrap functions.\r\n *\r\n * - It is important that `asyncAction should always be used with a generator function (recognizable as `function*` or `*name` syntax)\r\n * - Each yield statement should return a Promise. The generator function will continue as soon as the promise settles, with the settled value\r\n * - When the generator function finishes, you can return a normal value. The `asyncAction` wrapped function will always produce a promise delivering that value.\r\n *\r\n * When using the mobx devTools, an asyncAction will emit `action` events with names like:\r\n * * `\"fetchUsers - runid: 6 - init\"`\r\n * * `\"fetchUsers - runid: 6 - yield 0\"`\r\n * * `\"fetchUsers - runid: 6 - yield 1\"`\r\n *\r\n * The `runId` represents the generator instance. In other words, if `fetchUsers` is invoked multiple times concurrently, the events with the same `runid` belong together.\r\n * The `yield` number indicates the progress of the generator. `init` indicates spawning (it won't do anything, but you can find the original arguments of the `asyncAction` here).\r\n * `yield 0` ... `yield n` indicates the code block that is now being executed. `yield 0` is before the first `yield`, `yield 1` after the first one etc. Note that yield numbers are not determined lexically but by the runtime flow.\r\n *\r\n * `asyncActions` requires `Promise` and `generators` to be available on the target environment. Polyfill `Promise` if needed. Both TypeScript and Babel can compile generator functions down to ES5.\r\n *\r\n *  N.B. due to a [babel limitation](https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy/issues/26), in Babel generatos cannot be combined with decorators. See also [#70](https://github.com/mobxjs/mobx-utils/issues/70)\r\n *\r\n *\r\n * @example\r\n * import {asyncAction} from \"mobx-utils\"\r\n *\r\n * let users = []\r\n *\r\n * const fetchUsers = asyncAction(\"fetchUsers\", function* (url) {\r\n *   const start = Date.now()\r\n *   const data = yield window.fetch(url)\r\n *   users = yield data.json()\r\n *   return start - Date.now()\r\n * })\r\n *\r\n * fetchUsers(\"http://users.com\").then(time => {\r\n *   console.dir(\"Got users\", users, \"in \", time, \"ms\")\r\n * })\r\n *\r\n * @example\r\n * import {asyncAction} from \"mobx-utils\"\r\n *\r\n * mobx.configure({ enforceActions: \"observed\" }) // don't allow state modifications outside actions\r\n *\r\n * class Store {\r\n * \t\\@observable githubProjects = []\r\n * \t\\@observable = \"pending\" // \"pending\" / \"done\" / \"error\"\r\n *\r\n * \t\\@asyncAction\r\n * \t*fetchProjects() { // <- note the star, this a generator function!\r\n * \t\tthis.githubProjects = []\r\n * \t\tthis.state = \"pending\"\r\n * \t\ttry {\r\n * \t\t\tconst projects = yield fetchGithubProjectsSomehow() // yield instead of await\r\n * \t\t\tconst filteredProjects = somePreprocessing(projects)\r\n * \t\t\t// the asynchronous blocks will automatically be wrapped actions\r\n * \t\t\tthis.state = \"done\"\r\n * \t\t\tthis.githubProjects = filteredProjects\r\n * \t\t} catch (error) {\r\n * \t\t\tthis.state = \"error\"\r\n * \t\t}\r\n * \t}\r\n * }\r\n *\r\n * @export\r\n * @returns {Promise}\r\n */\r\nfunction asyncAction(arg1, arg2) {\r\n    // decorator\r\n    if (typeof arguments[1] === \"string\") {\r\n        var name_1 = arguments[1];\r\n        var descriptor_1 = arguments[2];\r\n        if (descriptor_1 && descriptor_1.value) {\r\n            return Object.assign({}, descriptor_1, {\r\n                value: flow(descriptor_1.value),\r\n            });\r\n        }\r\n        else {\r\n            return Object.assign({}, descriptor_1, {\r\n                set: function (v) {\r\n                    Object.defineProperty(this, name_1, __assign$1(__assign$1({}, descriptor_1), { value: flow(v) }));\r\n                },\r\n            });\r\n        }\r\n    }\r\n    // direct invocation\r\n    var generator = typeof arg1 === \"string\" ? arg2 : arg1;\r\n    var name = typeof arg1 === \"string\" ? arg1 : generator.name || \"<unnamed async action>\";\r\n    deprecated(\"asyncAction is deprecated. use mobx.flow instead\");\r\n    return flow(generator); // name get's dropped..\r\n}\n\n/**\r\n * _deprecated_ whenAsync is deprecated, use mobx.when without effect instead.\r\n *\r\n * Like normal `when`, except that this `when` will return a promise that resolves when the expression becomes truthy\r\n *\r\n * @example\r\n * await whenAsync(() => !state.someBoolean)\r\n *\r\n * @export\r\n * @param {() => boolean} fn see when, the expression to await\r\n * @param {number} timeout maximum amount of time to wait, before the promise rejects\r\n * @returns Promise for when an observable eventually matches some condition. Rejects if timeout is provided and has expired\r\n */\r\nfunction whenAsync(fn, timeout) {\r\n    if (timeout === void 0) { timeout = 0; }\r\n    deprecated(\"whenAsync is deprecated, use mobx.when without effect instead\");\r\n    return when(fn, {\r\n        timeout: timeout,\r\n    });\r\n}\n\n/**\r\n * expr can be used to create temporarily views inside views.\r\n * This can be improved to improve performance if a value changes often, but usually doesn't affect the outcome of an expression.\r\n *\r\n * In the following example the expression prevents that a component is rerender _each time_ the selection changes;\r\n * instead it will only rerenders when the current todo is (de)selected.\r\n *\r\n * @example\r\n * const Todo = observer((props) => {\r\n *     const todo = props.todo;\r\n *     const isSelected = mobxUtils.expr(() => props.viewState.selection === todo);\r\n *     return <div className={isSelected ? \"todo todo-selected\" : \"todo\"}>{todo.title}</div>\r\n * });\r\n *\r\n */\r\nfunction expr(expr) {\r\n    if (!_isComputingDerivation())\r\n        console.warn(\"'expr' should only be used inside other reactive functions.\");\r\n    // optimization: would be more efficient if the expr itself wouldn't be evaluated first on the next change, but just a 'changed' signal would be fired\r\n    return computed(expr).get();\r\n}\n\nvar __assign$2 = (undefined && undefined.__assign) || function () {\r\n    __assign$2 = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign$2.apply(this, arguments);\r\n};\r\nvar memoizationId = 0;\r\nfunction createTransformer(transformer, arg2) {\r\n    invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\r\n    // Memoizes: object id -> reactive view that applies transformer to the object\r\n    var views = {};\r\n    var onCleanup = undefined;\r\n    var keepAlive = false;\r\n    var debugNameGenerator = undefined;\r\n    if (typeof arg2 === \"object\") {\r\n        onCleanup = arg2.onCleanup;\r\n        keepAlive = arg2.keepAlive !== undefined ? arg2.keepAlive : false;\r\n        debugNameGenerator = arg2.debugNameGenerator;\r\n    }\r\n    else if (typeof arg2 === \"function\") {\r\n        onCleanup = arg2;\r\n    }\r\n    function createView(sourceIdentifier, sourceObject) {\r\n        var latestValue;\r\n        var computedValueOptions = {};\r\n        if (typeof arg2 === \"object\") {\r\n            onCleanup = arg2.onCleanup;\r\n            debugNameGenerator = arg2.debugNameGenerator;\r\n            computedValueOptions = arg2;\r\n        }\r\n        else if (typeof arg2 === \"function\") {\r\n            onCleanup = arg2;\r\n        }\r\n        else {\r\n            onCleanup = undefined;\r\n            debugNameGenerator = undefined;\r\n        }\r\n        var prettifiedName = debugNameGenerator\r\n            ? debugNameGenerator(sourceObject)\r\n            : \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier;\r\n        var expr = computed(function () {\r\n            return (latestValue = transformer(sourceObject));\r\n        }, __assign$2(__assign$2({}, computedValueOptions), { name: prettifiedName }));\r\n        if (!keepAlive) {\r\n            var disposer_1 = onBecomeUnobserved(expr, function () {\r\n                delete views[sourceIdentifier];\r\n                disposer_1();\r\n                if (onCleanup)\r\n                    onCleanup(latestValue, sourceObject);\r\n            });\r\n        }\r\n        return expr;\r\n    }\r\n    var memoWarned = false;\r\n    return function (object) {\r\n        var identifier = getMemoizationId(object);\r\n        var reactiveView = views[identifier];\r\n        if (reactiveView)\r\n            return reactiveView.get();\r\n        if (!keepAlive && !_isComputingDerivation()) {\r\n            if (!memoWarned) {\r\n                console.warn(\"invoking a transformer from outside a reactive context won't memorized \" +\r\n                    \"and is cleaned up immediately, unless keepAlive is set\");\r\n                memoWarned = true;\r\n            }\r\n            var value = transformer(object);\r\n            if (onCleanup)\r\n                onCleanup(value, object);\r\n            return value;\r\n        }\r\n        // Not in cache; create a reactive view\r\n        reactiveView = views[identifier] = createView(identifier, object);\r\n        return reactiveView.get();\r\n    };\r\n}\r\nfunction getMemoizationId(object) {\r\n    var objectType = typeof object;\r\n    if (objectType === \"string\")\r\n        return \"string:\" + object;\r\n    if (objectType === \"number\")\r\n        return \"number:\" + object;\r\n    if (object === null || (objectType !== \"object\" && objectType !== \"function\"))\r\n        throw new Error(\"[mobx-utils] transform expected an object, function, string or number, got: \" + String(object));\r\n    var tid = object.$transformId;\r\n    if (tid === undefined) {\r\n        tid = \"memoizationId:\" + ++memoizationId;\r\n        addHiddenProp(object, \"$transformId\", tid);\r\n    }\r\n    return tid;\r\n}\n\nfunction buildPath(entry) {\r\n    if (!entry)\r\n        return \"ROOT\";\r\n    var res = [];\r\n    while (entry.parent) {\r\n        res.push(entry.path);\r\n        entry = entry.parent;\r\n    }\r\n    return res.reverse().join(\"/\");\r\n}\r\nfunction isRecursivelyObservable(thing) {\r\n    return isObservableObject(thing) || isObservableArray(thing) || isObservableMap(thing);\r\n}\r\n/**\r\n * Given an object, deeply observes the given object.\r\n * It is like `observe` from mobx, but applied recursively, including all future children.\r\n *\r\n * Note that the given object cannot ever contain cycles and should be a tree.\r\n *\r\n * As benefit: path and root will be provided in the callback, so the signature of the listener is\r\n * (change, path, root) => void\r\n *\r\n * The returned disposer can be invoked to clean up the listener\r\n *\r\n * deepObserve cannot be used on computed values.\r\n *\r\n * @example\r\n * const disposer = deepObserve(target, (change, path) => {\r\n *    console.dir(change)\r\n * })\r\n */\r\nfunction deepObserve(target, listener) {\r\n    var entrySet = new WeakMap();\r\n    function genericListener(change) {\r\n        var entry = entrySet.get(change.object);\r\n        processChange(change, entry);\r\n        listener(change, buildPath(entry), target);\r\n    }\r\n    function processChange(change, parent) {\r\n        switch (change.type) {\r\n            // Object changes\r\n            case \"add\": // also for map\r\n                observeRecursively(change.newValue, parent, change.name);\r\n                break;\r\n            case \"update\": // also for array and map\r\n                unobserveRecursively(change.oldValue);\r\n                observeRecursively(change.newValue, parent, change.name || \"\" + change.index);\r\n                break;\r\n            case \"remove\": // object\r\n            case \"delete\": // map\r\n                unobserveRecursively(change.oldValue);\r\n                break;\r\n            // Array changes\r\n            case \"splice\":\r\n                change.removed.map(unobserveRecursively);\r\n                change.added.forEach(function (value, idx) {\r\n                    return observeRecursively(value, parent, \"\" + (change.index + idx));\r\n                });\r\n                // update paths\r\n                for (var i = change.index + change.addedCount; i < change.object.length; i++) {\r\n                    if (isRecursivelyObservable(change.object[i])) {\r\n                        var entry = entrySet.get(change.object[i]);\r\n                        if (entry)\r\n                            entry.path = \"\" + i;\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    function observeRecursively(thing, parent, path) {\r\n        if (isRecursivelyObservable(thing)) {\r\n            var entry = entrySet.get(thing);\r\n            if (entry) {\r\n                if (entry.parent !== parent || entry.path !== path)\r\n                    // MWE: this constraint is artificial, and this tool could be made to work with cycles,\r\n                    // but it increases administration complexity, has tricky edge cases and the meaning of 'path'\r\n                    // would become less clear. So doesn't seem to be needed for now\r\n                    throw new Error(\"The same observable object cannot appear twice in the same tree,\" +\r\n                        (\" trying to assign it to '\" + buildPath(parent) + \"/\" + path + \"',\") +\r\n                        (\" but it already exists at '\" + buildPath(entry.parent) + \"/\" + entry.path + \"'\"));\r\n            }\r\n            else {\r\n                var entry_1 = {\r\n                    parent: parent,\r\n                    path: path,\r\n                    dispose: observe(thing, genericListener),\r\n                };\r\n                entrySet.set(thing, entry_1);\r\n                entries(thing).forEach(function (_a) {\r\n                    var key = _a[0], value = _a[1];\r\n                    return observeRecursively(value, entry_1, key);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    function unobserveRecursively(thing) {\r\n        if (isRecursivelyObservable(thing)) {\r\n            var entry = entrySet.get(thing);\r\n            if (!entry)\r\n                return;\r\n            entrySet.delete(thing);\r\n            entry.dispose();\r\n            values(thing).forEach(unobserveRecursively);\r\n        }\r\n    }\r\n    observeRecursively(target, undefined, \"\");\r\n    return function () {\r\n        unobserveRecursively(target);\r\n    };\r\n}\n\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\n/**\r\n * Reactively sorts a base observable array into multiple observable arrays based on the value of a\r\n * `groupBy: (item: T) => G` function.\r\n *\r\n * This observes the individual computed groupBy values and only updates the source and dest arrays\r\n * when there is an actual change, so this is far more efficient than, for example\r\n * `base.filter(i => groupBy(i) === 'we')`. Call #dispose() to stop tracking.\r\n *\r\n * No guarantees are made about the order of items in the grouped arrays.\r\n *\r\n * The resulting map of arrays is read-only. clear(), set(), delete() are not supported and\r\n * modifying the group arrays will lead to undefined behavior.\r\n *\r\n * @param {array} base The array to sort into groups.\r\n * @param {function} groupBy The function used for grouping.\r\n * @param options Object with properties:\r\n *  `name`: Debug name of this ObservableGroupMap.\r\n *  `keyToName`: Function to create the debug names of the observable group arrays.\r\n *\r\n * @example\r\n * const slices = observable([\r\n *     { day: \"mo\", hours: 12 },\r\n *     { day: \"tu\", hours: 2 },\r\n * ])\r\n * const slicesByDay = new ObservableGroupMap(slices, (slice) => slice.day)\r\n * autorun(() => console.log(\r\n *     slicesByDay.get(\"mo\")?.length ?? 0,\r\n *     slicesByDay.get(\"we\"))) // outputs 1, undefined\r\n * slices[0].day = \"we\" // outputs 0, [{ day: \"we\", hours: 12 }]\r\n */\r\nvar ObservableGroupMap = /** @class */ (function (_super) {\r\n    __extends(ObservableGroupMap, _super);\r\n    function ObservableGroupMap(base, groupBy, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.name, name = _c === void 0 ? \"ogm\" + ((Math.random() * 1000) | 0) : _c, _d = _b.keyToName, keyToName = _d === void 0 ? function (x) { return \"\" + x; } : _d;\r\n        var _this = _super.call(this) || this;\r\n        _this._keyToName = keyToName;\r\n        _this._groupBy = groupBy;\r\n        _this._ogmInfoKey = (\"function\" == typeof Symbol\r\n            ? Symbol(\"ogmInfo\" + name)\r\n            : \"__ogmInfo\" + name);\r\n        _this._base = base;\r\n        for (var i = 0; i < base.length; i++) {\r\n            _this._addItem(base[i]);\r\n        }\r\n        _this._disposeBaseObserver = observe(_this._base, function (change) {\r\n            if (\"splice\" === change.type) {\r\n                transaction(function () {\r\n                    for (var _i = 0, _a = change.removed; _i < _a.length; _i++) {\r\n                        var removed = _a[_i];\r\n                        _this._removeItem(removed);\r\n                    }\r\n                    for (var _b = 0, _c = change.added; _b < _c.length; _b++) {\r\n                        var added = _c[_b];\r\n                        _this._addItem(added);\r\n                    }\r\n                });\r\n            }\r\n            else if (\"update\" === change.type) {\r\n                transaction(function () {\r\n                    _this._removeItem(change.oldValue);\r\n                    _this._addItem(change.newValue);\r\n                });\r\n            }\r\n            else {\r\n                throw new Error(\"illegal state\");\r\n            }\r\n        });\r\n        return _this;\r\n    }\r\n    ObservableGroupMap.prototype.clear = function () {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    ObservableGroupMap.prototype.delete = function (_key) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    ObservableGroupMap.prototype.set = function (_key, _value) {\r\n        throw new Error(\"not supported\");\r\n    };\r\n    /**\r\n     * Disposes all observers created during construction and removes state added to base array\r\n     * items.\r\n     */\r\n    ObservableGroupMap.prototype.dispose = function () {\r\n        this._disposeBaseObserver();\r\n        for (var i = 0; i < this._base.length; i++) {\r\n            var item = this._base[i];\r\n            var grouperItemInfo = item[this._ogmInfoKey];\r\n            grouperItemInfo.reaction();\r\n            delete item[this._ogmInfoKey];\r\n        }\r\n    };\r\n    ObservableGroupMap.prototype._getGroupArr = function (key) {\r\n        var result = _super.prototype.get.call(this, key);\r\n        if (undefined === result) {\r\n            result = observable([], { name: \"GroupArray[\" + this._keyToName(key) + \"]\" });\r\n            _super.prototype.set.call(this, key, result);\r\n        }\r\n        return result;\r\n    };\r\n    ObservableGroupMap.prototype._removeFromGroupArr = function (key, itemIndex) {\r\n        var arr = _super.prototype.get.call(this, key);\r\n        if (1 === arr.length) {\r\n            _super.prototype.delete.call(this, key);\r\n        }\r\n        else if (itemIndex === arr.length - 1) {\r\n            // last position in array\r\n            arr.length--;\r\n        }\r\n        else {\r\n            arr[itemIndex] = arr[arr.length - 1];\r\n            arr[itemIndex][this._ogmInfoKey].groupArrIndex = itemIndex;\r\n            arr.length--;\r\n        }\r\n    };\r\n    ObservableGroupMap.prototype._addItem = function (item) {\r\n        var _this = this;\r\n        var groupByValue = this._groupBy(item);\r\n        var groupArr = this._getGroupArr(groupByValue);\r\n        var value = {\r\n            groupByValue: groupByValue,\r\n            groupArrIndex: groupArr.length,\r\n            reaction: reaction(function () { return _this._groupBy(item); }, function (newGroupByValue, _r) {\r\n                console.log(\"new group by value \", newGroupByValue);\r\n                var grouperItemInfo = item[_this._ogmInfoKey];\r\n                _this._removeFromGroupArr(grouperItemInfo.groupByValue, grouperItemInfo.groupArrIndex);\r\n                var newGroupArr = _this._getGroupArr(newGroupByValue);\r\n                var newGroupArrIndex = newGroupArr.length;\r\n                newGroupArr.push(item);\r\n                grouperItemInfo.groupByValue = newGroupByValue;\r\n                grouperItemInfo.groupArrIndex = newGroupArrIndex;\r\n            }),\r\n        };\r\n        Object.defineProperty(item, this._ogmInfoKey, {\r\n            configurable: true,\r\n            enumerable: false,\r\n            value: value,\r\n        });\r\n        groupArr.push(item);\r\n    };\r\n    ObservableGroupMap.prototype._removeItem = function (item) {\r\n        var grouperItemInfo = item[this._ogmInfoKey];\r\n        this._removeFromGroupArr(grouperItemInfo.groupByValue, grouperItemInfo.groupArrIndex);\r\n        grouperItemInfo.reaction();\r\n        delete item[this._ogmInfoKey];\r\n    };\r\n    return ObservableGroupMap;\r\n}(ObservableMap));\n\n/**\r\n * @private\r\n */\r\nvar DeepMapEntry = /** @class */ (function () {\r\n    function DeepMapEntry(base, args) {\r\n        this.base = base;\r\n        this.args = args;\r\n        this.closestIdx = 0;\r\n        this.isDisposed = false;\r\n        var current = (this.closest = this.root = base);\r\n        var i = 0;\r\n        for (; i < this.args.length - 1; i++) {\r\n            current = current.get(args[i]);\r\n            if (current)\r\n                this.closest = current;\r\n            else\r\n                break;\r\n        }\r\n        this.closestIdx = i;\r\n    }\r\n    DeepMapEntry.prototype.exists = function () {\r\n        this.assertNotDisposed();\r\n        var l = this.args.length;\r\n        return this.closestIdx >= l - 1 && this.closest.has(this.args[l - 1]);\r\n    };\r\n    DeepMapEntry.prototype.get = function () {\r\n        this.assertNotDisposed();\r\n        if (!this.exists())\r\n            throw new Error(\"Entry doesn't exist\");\r\n        return this.closest.get(this.args[this.args.length - 1]);\r\n    };\r\n    DeepMapEntry.prototype.set = function (value) {\r\n        this.assertNotDisposed();\r\n        var l = this.args.length;\r\n        var current = this.closest;\r\n        // create remaining maps\r\n        for (var i = this.closestIdx; i < l - 1; i++) {\r\n            var m = new Map();\r\n            current.set(this.args[i], m);\r\n            current = m;\r\n        }\r\n        this.closestIdx = l - 1;\r\n        this.closest = current;\r\n        current.set(this.args[l - 1], value);\r\n    };\r\n    DeepMapEntry.prototype.delete = function () {\r\n        this.assertNotDisposed();\r\n        if (!this.exists())\r\n            throw new Error(\"Entry doesn't exist\");\r\n        var l = this.args.length;\r\n        this.closest.delete(this.args[l - 1]);\r\n        // clean up remaining maps if needed (reconstruct stack first)\r\n        var c = this.root;\r\n        var maps = [c];\r\n        for (var i = 0; i < l - 1; i++) {\r\n            c = c.get(this.args[i]);\r\n            maps.push(c);\r\n        }\r\n        for (var i = maps.length - 1; i > 0; i--) {\r\n            if (maps[i].size === 0)\r\n                maps[i - 1].delete(this.args[i - 1]);\r\n        }\r\n        this.isDisposed = true;\r\n    };\r\n    DeepMapEntry.prototype.assertNotDisposed = function () {\r\n        // TODO: once this becomes annoying, we should introduce a reset method to re-run the constructor logic\r\n        if (this.isDisposed)\r\n            throw new Error(\"Concurrent modification exception\");\r\n    };\r\n    return DeepMapEntry;\r\n}());\r\n/**\r\n * @private\r\n */\r\nvar DeepMap = /** @class */ (function () {\r\n    function DeepMap() {\r\n        this.store = new Map();\r\n        this.argsLength = -1;\r\n    }\r\n    DeepMap.prototype.entry = function (args) {\r\n        if (this.argsLength === -1)\r\n            this.argsLength = args.length;\r\n        else if (this.argsLength !== args.length)\r\n            throw new Error(\"DeepMap should be used with functions with a consistent length, expected: \" + this.argsLength + \", got: \" + args.length);\r\n        if (this.last)\r\n            this.last.isDisposed = true;\r\n        return (this.last = new DeepMapEntry(this.store, args));\r\n    };\r\n    return DeepMap;\r\n}());\n\nvar __assign$3 = (undefined && undefined.__assign) || function () {\r\n    __assign$3 = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign$3.apply(this, arguments);\r\n};\r\n/**\r\n * computedFn takes a function with an arbitrary amount of arguments,\r\n * and memoizes the output of the function based on the arguments passed in.\r\n *\r\n * computedFn(fn) returns a function with the very same signature. There is no limit on the amount of arguments\r\n * that is accepted. However, the amount of arguments must be constant and default arguments are not supported.\r\n *\r\n * By default the output of a function call will only be memoized as long as the\r\n * output is being observed.\r\n *\r\n * The function passes into `computedFn` should be pure, not be an action and only be relying on\r\n * observables.\r\n *\r\n * Setting `keepAlive` to `true` will cause the output to be forcefully cached forever.\r\n * Note that this might introduce memory leaks!\r\n *\r\n * @example\r\n * const store = observable({\r\n    a: 1,\r\n    b: 2,\r\n    c: 3,\r\n    m: computedFn(function(x) {\r\n      return this.a * this.b * x\r\n    })\r\n  })\r\n\r\n  const d = autorun(() => {\r\n    // store.m(3) will be cached as long as this autorun is running\r\n    console.log(store.m(3) * store.c)\r\n  })\r\n *\r\n * @param fn\r\n * @param keepAliveOrOptions\r\n */\r\nfunction computedFn(fn, keepAliveOrOptions) {\r\n    if (keepAliveOrOptions === void 0) { keepAliveOrOptions = false; }\r\n    if (isAction(fn))\r\n        throw new Error(\"computedFn shouldn't be used on actions\");\r\n    var memoWarned = false;\r\n    var i = 0;\r\n    var opts = typeof keepAliveOrOptions === \"boolean\"\r\n        ? { keepAlive: keepAliveOrOptions }\r\n        : keepAliveOrOptions;\r\n    var d = new DeepMap();\r\n    return function () {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var entry = d.entry(args);\r\n        // cache hit, return\r\n        if (entry.exists())\r\n            return entry.get().get();\r\n        // if function is invoked, and its a cache miss without reactive, there is no point in caching...\r\n        if (!opts.keepAlive && !_isComputingDerivation()) {\r\n            if (!memoWarned) {\r\n                console.warn(\"invoking a computedFn from outside an reactive context won't be memoized, unless keepAlive is set\");\r\n                memoWarned = true;\r\n            }\r\n            return fn.apply(this, args);\r\n        }\r\n        // create new entry\r\n        var c = computed(function () {\r\n            return fn.apply(_this, args);\r\n        }, __assign$3(__assign$3({}, opts), { name: \"computedFn(\" + fn.name + \"#\" + ++i + \")\" }));\r\n        entry.set(c);\r\n        // clean up if no longer observed\r\n        if (!opts.keepAlive)\r\n            onBecomeUnobserved(c, function () {\r\n                d.entry(args).delete();\r\n            });\r\n        // return current val\r\n        return c.get();\r\n    };\r\n}\n\nfunction decorateMethodOrField(decoratorName, decorateFn, target, prop, descriptor) {\r\n    if (descriptor) {\r\n        return decorateMethod(decoratorName, decorateFn, prop, descriptor);\r\n    }\r\n    else {\r\n        decorateField(decorateFn, target, prop);\r\n    }\r\n}\r\nfunction decorateMethod(decoratorName, decorateFn, prop, descriptor) {\r\n    if (descriptor.get !== undefined) {\r\n        return fail(decoratorName + \" cannot be used with getters\");\r\n    }\r\n    // babel / typescript\r\n    // @action method() { }\r\n    if (descriptor.value) {\r\n        // typescript\r\n        return {\r\n            value: decorateFn(prop, descriptor.value),\r\n            enumerable: false,\r\n            configurable: true,\r\n            writable: true,\r\n        };\r\n    }\r\n    // babel only: @action method = () => {}\r\n    var initializer = descriptor.initializer;\r\n    return {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        initializer: function () {\r\n            // N.B: we can't immediately invoke initializer; this would be wrong\r\n            return decorateFn(prop, initializer.call(this));\r\n        },\r\n    };\r\n}\r\nfunction decorateField(decorateFn, target, prop) {\r\n    // Simple property that writes on first invocation to the current instance\r\n    Object.defineProperty(target, prop, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        get: function () {\r\n            return undefined;\r\n        },\r\n        set: function (value) {\r\n            addHiddenProp(this, prop, decorateFn(prop, value));\r\n        },\r\n    });\r\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (undefined && undefined.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nvar runId = 0;\r\nvar unfinishedIds = new Set();\r\nvar currentlyActiveIds = new Set();\r\nvar inOrderExecution;\r\n{\r\n    var taskOrderPromise_1 = Promise.resolve();\r\n    var queueMicrotaskPolyfill_1;\r\n    if (typeof queueMicrotask !== \"undefined\") {\r\n        // use real implementation if possible in modern browsers/node\r\n        queueMicrotaskPolyfill_1 = queueMicrotask;\r\n    }\r\n    else if (typeof process !== \"undefined\" && process.nextTick) {\r\n        // fallback to node's process.nextTick in node <= 10\r\n        queueMicrotaskPolyfill_1 = function (cb) {\r\n            process.nextTick(cb);\r\n        };\r\n    }\r\n    else {\r\n        // use setTimeout for old browsers\r\n        queueMicrotaskPolyfill_1 = function (cb) {\r\n            setTimeout(cb, 0);\r\n        };\r\n    }\r\n    var idle_1 = function () {\r\n        return new Promise(function (r) {\r\n            queueMicrotaskPolyfill_1(r);\r\n        });\r\n    };\r\n    // we use this trick to force a proper order of execution\r\n    // even for immediately resolved promises\r\n    inOrderExecution = function () {\r\n        taskOrderPromise_1 = taskOrderPromise_1.then(idle_1);\r\n        return taskOrderPromise_1;\r\n    };\r\n}\r\nvar actionAsyncContextStack = [];\r\nfunction task(value) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var ctx, runId, actionName, args, scope, actionRunInfo, step, nextStep, ret, err_1, actionRunInfo_1;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    ctx = actionAsyncContextStack[actionAsyncContextStack.length - 1];\r\n                    if (!ctx) {\r\n                        fail$1(\"'actionAsync' context not present when running 'task'. did you await inside an 'actionAsync' without using 'task(promise)'? did you forget to await the task?\");\r\n                    }\r\n                    runId = ctx.runId, actionName = ctx.actionName, args = ctx.args, scope = ctx.scope, actionRunInfo = ctx.actionRunInfo, step = ctx.step;\r\n                    nextStep = step + 1;\r\n                    actionAsyncContextStack.pop();\r\n                    _endAction(actionRunInfo);\r\n                    currentlyActiveIds.delete(runId);\r\n                    _a.label = 1;\r\n                case 1:\r\n                    _a.trys.push([1, 4, 6, 7]);\r\n                    return [4 /*yield*/, value];\r\n                case 2:\r\n                    ret = _a.sent();\r\n                    return [4 /*yield*/, inOrderExecution()];\r\n                case 3:\r\n                    _a.sent();\r\n                    return [2 /*return*/, ret];\r\n                case 4:\r\n                    err_1 = _a.sent();\r\n                    return [4 /*yield*/, inOrderExecution()];\r\n                case 5:\r\n                    _a.sent();\r\n                    throw err_1;\r\n                case 6:\r\n                    // only restart if it not a dangling promise (the action is not yet finished)\r\n                    if (unfinishedIds.has(runId)) {\r\n                        actionRunInfo_1 = _startAction(getActionAsyncName(actionName, runId, nextStep), this, args);\r\n                        actionAsyncContextStack.push({\r\n                            runId: runId,\r\n                            step: nextStep,\r\n                            actionRunInfo: actionRunInfo_1,\r\n                            actionName: actionName,\r\n                            args: args,\r\n                            scope: scope,\r\n                        });\r\n                        currentlyActiveIds.add(runId);\r\n                    }\r\n                    return [7 /*endfinally*/];\r\n                case 7: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n// base\r\n/**\r\n * Alternative syntax for async actions, similar to `flow` but more compatible with\r\n * Typescript typings. Not to be confused with `asyncAction`, which is deprecated.\r\n *\r\n * `actionAsync` can be used either as a decorator or as a function.\r\n * It takes an async function that internally must use `await task(promise)` rather than\r\n * the standard `await promise`.\r\n *\r\n * When using the mobx devTools, an asyncAction will emit `action` events with names like:\r\n * * `\"fetchUsers - runid 6 - step 0\"`\r\n * * `\"fetchUsers - runid 6 - step 1\"`\r\n * * `\"fetchUsers - runid 6 - step 2\"`\r\n *\r\n * The `runId` represents the action instance. In other words, if `fetchUsers` is invoked\r\n * multiple times concurrently, the events with the same `runid` belong together.\r\n * The `step` number indicates the code block that is now being executed.\r\n *\r\n * @example\r\n * import {actionAsync, task} from \"mobx-utils\"\r\n *\r\n * let users = []\r\n *\r\n * const fetchUsers = actionAsync(\"fetchUsers\", async (url) => {\r\n *   const start = Date.now()\r\n *   // note the use of task when awaiting!\r\n *   const data = await task(window.fetch(url))\r\n *   users = await task(data.json())\r\n *   return start - Date.now()\r\n * })\r\n *\r\n * const time = await fetchUsers(\"http://users.com\")\r\n * console.log(\"Got users\", users, \"in \", time, \"ms\")\r\n *\r\n * @example\r\n * import {actionAsync, task} from \"mobx-utils\"\r\n *\r\n * mobx.configure({ enforceActions: \"observed\" }) // don't allow state modifications outside actions\r\n *\r\n * class Store {\r\n *   \\@observable githubProjects = []\r\n *   \\@observable = \"pending\" // \"pending\" / \"done\" / \"error\"\r\n *\r\n *   \\@actionAsync\r\n *   async fetchProjects() {\r\n *     this.githubProjects = []\r\n *     this.state = \"pending\"\r\n *     try {\r\n *       // note the use of task when awaiting!\r\n *       const projects = await task(fetchGithubProjectsSomehow())\r\n *       const filteredProjects = somePreprocessing(projects)\r\n *       // the asynchronous blocks will automatically be wrapped actions\r\n *       this.state = \"done\"\r\n *       this.githubProjects = filteredProjects\r\n *     } catch (error) {\r\n *        this.state = \"error\"\r\n *     }\r\n *   }\r\n * }\r\n */\r\nfunction actionAsync(arg1, arg2, arg3) {\r\n    // decorator\r\n    if (typeof arguments[1] === \"string\") {\r\n        return decorateMethodOrField(\"@actionAsync\", function (prop, v) {\r\n            return actionAsyncFn(prop, v);\r\n        }, arg1, arg2, arg3);\r\n    }\r\n    // direct invocation\r\n    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action>\";\r\n    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\r\n    return actionAsyncFn(actionName, fn);\r\n}\r\nfunction actionAsyncFn(actionName, fn) {\r\n    if (!_startAction || !_endAction) {\r\n        fail$1(\"'actionAsync' requires mobx >=5.13.1 or >=4.13.1\");\r\n    }\r\n    invariant(typeof fn === \"function\", \"'asyncAction' expects a function\");\r\n    if (typeof actionName !== \"string\" || !actionName)\r\n        fail$1(\"actions should have valid names, got: '\" + actionName + \"'\");\r\n    return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var nextRunId, actionRunInfo, finish, promise, ret, err_2;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        nextRunId = runId++;\r\n                        unfinishedIds.add(nextRunId);\r\n                        actionRunInfo = _startAction(getActionAsyncName(actionName, nextRunId, 0), this, args);\r\n                        actionAsyncContextStack.push({\r\n                            runId: nextRunId,\r\n                            step: 0,\r\n                            actionRunInfo: actionRunInfo,\r\n                            actionName: actionName,\r\n                            args: args,\r\n                            scope: this,\r\n                        });\r\n                        currentlyActiveIds.add(nextRunId);\r\n                        finish = function (err) {\r\n                            unfinishedIds.delete(nextRunId);\r\n                            var ctx = actionAsyncContextStack.pop();\r\n                            if (!ctx || ctx.runId !== nextRunId) {\r\n                                // push it back if invalid\r\n                                if (ctx) {\r\n                                    actionAsyncContextStack.push(ctx);\r\n                                }\r\n                                var msg = \"invalid 'actionAsync' context when finishing action '\" + actionName + \"'.\";\r\n                                if (!ctx) {\r\n                                    msg += \" no action context could be found instead.\";\r\n                                }\r\n                                else {\r\n                                    msg += \" an action context for '\" + ctx.actionName + \"' was found instead.\";\r\n                                }\r\n                                msg +=\r\n                                    \" did you await inside an 'actionAsync' without using 'task(promise)'? did you forget to await the task?\";\r\n                                fail$1(msg);\r\n                            }\r\n                            ctx.actionRunInfo.error = err;\r\n                            _endAction(ctx.actionRunInfo);\r\n                            currentlyActiveIds.delete(nextRunId);\r\n                            if (err) {\r\n                                throw err;\r\n                            }\r\n                        };\r\n                        try {\r\n                            promise = fn.apply(this, args);\r\n                        }\r\n                        catch (err) {\r\n                            finish(err);\r\n                        }\r\n                        // are we done sync? (no task run)\r\n                        if (currentlyActiveIds.has(nextRunId)) {\r\n                            finish(undefined);\r\n                            return [2 /*return*/, promise];\r\n                        }\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, promise];\r\n                    case 2:\r\n                        ret = _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        err_2 = _a.sent();\r\n                        finish(err_2);\r\n                        return [3 /*break*/, 4];\r\n                    case 4:\r\n                        finish(undefined);\r\n                        return [2 /*return*/, ret];\r\n                }\r\n            });\r\n        });\r\n    };\r\n}\r\nfunction getActionAsyncName(actionName, runId, step) {\r\n    return actionName + \" - runid \" + runId + \" - step \" + step;\r\n}\n\nexport { FULFILLED, IDENTITY, NOOP, ObservableGroupMap, PENDING, REJECTED, ViewModel, actionAsync, addHiddenProp, asyncAction, chunkProcessor, computedFn, createTransformer, createViewModel, deepObserve, deprecated, expr, fail$1 as fail, fromPromise, fromResource, fromStream, getAllMethodsAndProperties, invariant, isPromiseBasedObservable, keepAlive, lazyObservable, moveItem, now, queueProcessor, task, toStream, whenAsync, whenWithTimeout };\n","/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { InnerSubscriber } from '../InnerSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { map } from './map';\nimport { from } from '../observable/from';\nexport function switchMap(project, resultSelector) {\n    if (typeof resultSelector === 'function') {\n        return function (source) { return source.pipe(switchMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };\n    }\n    return function (source) { return source.lift(new SwitchMapOperator(project)); };\n}\nvar SwitchMapOperator = /*@__PURE__*/ (function () {\n    function SwitchMapOperator(project) {\n        this.project = project;\n    }\n    SwitchMapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));\n    };\n    return SwitchMapOperator;\n}());\nvar SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SwitchMapSubscriber, _super);\n    function SwitchMapSubscriber(destination, project) {\n        var _this = _super.call(this, destination) || this;\n        _this.project = project;\n        _this.index = 0;\n        return _this;\n    }\n    SwitchMapSubscriber.prototype._next = function (value) {\n        var result;\n        var index = this.index++;\n        try {\n            result = this.project(value, index);\n        }\n        catch (error) {\n            this.destination.error(error);\n            return;\n        }\n        this._innerSub(result, value, index);\n    };\n    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {\n        var innerSubscription = this.innerSubscription;\n        if (innerSubscription) {\n            innerSubscription.unsubscribe();\n        }\n        var innerSubscriber = new InnerSubscriber(this, value, index);\n        var destination = this.destination;\n        destination.add(innerSubscriber);\n        this.innerSubscription = subscribeToResult(this, result, undefined, undefined, innerSubscriber);\n        if (this.innerSubscription !== innerSubscriber) {\n            destination.add(this.innerSubscription);\n        }\n    };\n    SwitchMapSubscriber.prototype._complete = function () {\n        var innerSubscription = this.innerSubscription;\n        if (!innerSubscription || innerSubscription.closed) {\n            _super.prototype._complete.call(this);\n        }\n        this.unsubscribe();\n    };\n    SwitchMapSubscriber.prototype._unsubscribe = function () {\n        this.innerSubscription = null;\n    };\n    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {\n        var destination = this.destination;\n        destination.remove(innerSub);\n        this.innerSubscription = null;\n        if (this.isStopped) {\n            _super.prototype._complete.call(this);\n        }\n    };\n    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.destination.next(innerValue);\n    };\n    return SwitchMapSubscriber;\n}(OuterSubscriber));\n//# sourceMappingURL=switchMap.js.map\n","/** PURE_IMPORTS_START _Observable,_util_isArray,_operators_map,_util_isObject,_from PURE_IMPORTS_END */\nimport { Observable } from '../Observable';\nimport { isArray } from '../util/isArray';\nimport { map } from '../operators/map';\nimport { isObject } from '../util/isObject';\nimport { from } from './from';\nexport function forkJoin() {\n    var sources = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        sources[_i] = arguments[_i];\n    }\n    if (sources.length === 1) {\n        var first_1 = sources[0];\n        if (isArray(first_1)) {\n            return forkJoinInternal(first_1, null);\n        }\n        if (isObject(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {\n            var keys = Object.keys(first_1);\n            return forkJoinInternal(keys.map(function (key) { return first_1[key]; }), keys);\n        }\n    }\n    if (typeof sources[sources.length - 1] === 'function') {\n        var resultSelector_1 = sources.pop();\n        sources = (sources.length === 1 && isArray(sources[0])) ? sources[0] : sources;\n        return forkJoinInternal(sources, null).pipe(map(function (args) { return resultSelector_1.apply(void 0, args); }));\n    }\n    return forkJoinInternal(sources, null);\n}\nfunction forkJoinInternal(sources, keys) {\n    return new Observable(function (subscriber) {\n        var len = sources.length;\n        if (len === 0) {\n            subscriber.complete();\n            return;\n        }\n        var values = new Array(len);\n        var completed = 0;\n        var emitted = 0;\n        var _loop_1 = function (i) {\n            var source = from(sources[i]);\n            var hasValue = false;\n            subscriber.add(source.subscribe({\n                next: function (value) {\n                    if (!hasValue) {\n                        hasValue = true;\n                        emitted++;\n                    }\n                    values[i] = value;\n                },\n                error: function (err) { return subscriber.error(err); },\n                complete: function () {\n                    completed++;\n                    if (completed === len || !hasValue) {\n                        if (emitted === len) {\n                            subscriber.next(keys ?\n                                keys.reduce(function (result, key, i) { return (result[key] = values[i], result); }, {}) :\n                                values);\n                        }\n                        subscriber.complete();\n                    }\n                }\n            }));\n        };\n        for (var i = 0; i < len; i++) {\n            _loop_1(i);\n        }\n    });\n}\n//# sourceMappingURL=forkJoin.js.map\n"],"sourceRoot":""}